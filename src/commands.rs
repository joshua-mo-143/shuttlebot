use crate::utils::Thread;
use crate::Context;
use crate::Error;
use poise::serenity_prelude::CacheHttp;
use tracing::error;

/// Link to Shuttle documentation
#[poise::command(slash_command)]
pub async fn docs(
    ctx: Context<'_>,
    #[description = "The docs you want to link to"] docs: DocsLinks,
) -> Result<(), Error> {
    ctx.say(docs.to_link()).await?;
    Ok(())
}

/// Elevate a Discord help thread to a GitHub issue. This locks the thread.
#[poise::command(slash_command)]
pub async fn elevate(
    ctx: Context<'_>,
    #[description = "Add extra contextual notes"] notes: Option<String>,
) -> Result<(), Error> {
    let notes = if notes.is_some() {
        notes.unwrap()
    } else {
        "None".to_string()
    };

    let topic = Thread::get(ctx).await.name;

    let thread_url = {
        format!(
            "https://discord.com/channels/{}/{}",
            ctx.guild_id().unwrap(),
            ctx.channel_id()
        )
    };

    let messages = ctx
        .channel_id()
        .messages(ctx.http(), |message| message)
        .await
        .unwrap();

    let first_message = messages.last().unwrap();
    let original_poster = first_message.author.name.clone();
    let message_content = first_message.content.clone();

    let issue_title = format!("[AUTOGENERATED] {topic}");

    let message = format!("This issue was autogenerated by shuttlebot. The issue was originally created by {original_poster} on discord. You can find the discord thread [here.]({thread_url}) \n
            Notes: {notes}\n
            ---\n
            Original message: {message_content}");

    match ctx
        .data()
        .crab
        .issues("joshua-mo-143", "test")
        .create(issue_title)
        .body(message)
        .send()
        .await
    {
        Ok(res) => {
            ctx.say(format!("This issue was successfully elevated to a GitHub issue! You can find the issue at: {}
                \n---\n
                The thread will now be locked to avoid needing to keep both communication channels synced with each other. 
                \nIf you're not the original poster and you're having the same issue, please open a new Help thread or comment on the GitHub issue.
                \n---\n
                Thank you!", res.html_url))
                .await?;

            Thread::set_locked_status(ctx, true).await?;

            sqlx::query(
                "UPDATE issues
                GithubLink = $1, 
                Locked = true, 
                Resolved = true,
                ResolverUserId = $2
                LockStatusChangeReason = 'Thread was elevated to Github issue', 
                ResolvedTimedate = CURRENT_TIMESTAMP 
                WHERE DiscordThreadId = $3",
            )
            .bind(res.html_url.to_string())
            .bind(ctx.author().id.to_string())
            .bind(ctx.channel_id().to_string())
            .execute(&ctx.data().pool)
            .await;
        }
        Err(e) => {
            error!("Error creating Github issue: {:?}", e);
        }
    }

    Ok(())
}

/// (un)Lock a thread
#[poise::command(slash_command)]
pub async fn set_locked(
    ctx: Context<'_>,
    #[description = "Set true to lock, set false to unlock"] locked: bool,
    #[description = "Reason for locking thread"] reason: String,
) -> Result<(), Error> {
    let message = if locked {
        format!("Locking thread. Reason: {reason}")
    } else {
        format!("Unlocking thread. Reason: {reason}")
    };

    ctx.say(message).await?;
    Thread::set_locked_status(ctx, locked).await?;

    sqlx::query(
        "UPDATE issues 
        Locked = $1, 
        LockStatusChangeReason = $2, 
        ResolvedTimedate = CURRENT_TIMESTAMP 
        WHERE DiscordThreadId = $3",
    )
    .bind(locked)
    .bind(reason)
    .bind(ctx.channel_id().to_string())
    .execute(&ctx.data().pool)
    .await;
    Ok(())
}

#[poise::command(slash_command)]
pub async fn resolve(ctx: Context<'_>) -> Result<(), Error> {
    let name = ctx.author().name.clone();

    let message = format!("It looks like this thread has been resolved, so {name} has invoked this command. 
        The thread will now be locked.\n 
        If you're still having an issue with this, please feel free to open another thread detailing your issue.");

    ctx.say(message).await?;
    Thread::set_locked_status(ctx, true).await?;

    sqlx::query(
        "UPDATE issues 
        Locked = true, 
        LockStatusChangeReason = 'Thread was resolved', 
        ResolvedTimedate = CURRENT_TIMESTAMP 
        WHERE DiscordThreadId = $1",
    )
    .bind(ctx.channel_id().to_string())
    .execute(&ctx.data().pool)
    .await;
    Ok(())
}

#[derive(Debug, poise::ChoiceParameter)]
pub enum DocsLinks {
    #[name = "documentation on setting up secrets/env"]
    Secrets,
    #[name = "documentation on provisioned databases via shared databases"]
    Databases,
    #[name = "documentation on setting up a simple key-value store"]
    Persist,
    #[name = "documentation on setting up static files"]
    Assets,
    #[name = "Documentation on setting up a custom service"]
    Custom,
}

impl DocsLinks {
    pub fn to_link(&self) -> String {
        match self {
            DocsLinks::Secrets => String::from("https://docs.shuttle.rs/resources/shuttle-secrets"),
            DocsLinks::Databases => {
                String::from("https://docs.shuttle.rs/resources/shuttle-shared-db")
            }
            DocsLinks::Persist => String::from("https://docs.shuttle.rs/resources/shuttle-persist"),
            DocsLinks::Assets => {
                String::from("https://docs.shuttle.rs/resources/shuttle-static-folder")
            }
            DocsLinks::Custom => String::from("https://docs.shuttle.rs/tutorials/custom-service"),
        }
    }
}
