use crate::utils::Thread;
use crate::Context;
use crate::Error;
use poise::serenity_prelude::{CacheHttp, Error as SerenityError,
};
use std::collections::HashMap;
use tracing::error;
use octocrab::models::IssueState;
use sqlx::types::chrono::Utc;

/// Link to Shuttle documentation
#[poise::command(slash_command)]
pub async fn docs(
    ctx: Context<'_>,
    #[description = "The docs you want to link to"] docs: DocsLinks,
) -> Result<(), Error> {
    ctx.say(docs.to_link()).await?;
    Ok(())
}

#[derive(Debug, poise::ChoiceParameter)]
pub enum DocsLinks {
    #[name = "documentation on setting up secrets/env"]
    Secrets,
    #[name = "documentation on provisioned databases via shared databases"]
    Databases,
    #[name = "documentation on setting up a simple key-value store"]
    Persist,
    #[name = "documentation on setting up static files"]
    Assets,
    #[name = "Documentation on setting up a custom service"]
    Custom,
}

impl DocsLinks {
    pub fn to_link(&self) -> String {
        match self {
            DocsLinks::Secrets => String::from("https://docs.shuttle.rs/resources/shuttle-secrets"),
            DocsLinks::Databases => {
                String::from("https://docs.shuttle.rs/resources/shuttle-shared-db")
            }
            DocsLinks::Persist => String::from("https://docs.shuttle.rs/resources/shuttle-persist"),
            DocsLinks::Assets => {
                String::from("https://docs.shuttle.rs/resources/shuttle-static-folder")
            }
            DocsLinks::Custom => String::from("https://docs.shuttle.rs/tutorials/custom-service"),
        }
    }
}

async fn check_role(ctx: Context<'_>) -> Result<bool, Error> {
    let Ok(res) = ctx.author().has_role(
        ctx.http(),
        ctx.data().server_id.parse::<u64>().unwrap(),
        ctx.data().staff_role_id.parse::<u64>().unwrap()
    ).await else {
         {error!("Something went wrong trying to check permissions.");
        return Ok(false)}
    };

    match res {
        true => Ok(true),
        false => Ok(false),
    }
}

/// Elevate a Discord help thread to a GitHub issue. This locks the thread.
#[poise::command(slash_command, check = "check_role")]
pub async fn elevate(ctx: Context<'_>) -> Result<(), Error> {
    let topic = Thread::get(ctx).await.name;

    let thread_url = Thread::url_from_poise_ctx(ctx);

    let messages = ctx
        .channel_id()
        .messages(ctx.http(), |message| message)
        .await
        .unwrap();

    let first_message = messages.last().unwrap();

    let message_content = first_message.content.clone();

    let issue_title = format!("[AUTOGENERATED] {topic}");

    let message = format!(
        "<sub>Generated from a [discord help thread.]({thread_url})</sub>\n---\n{message_content}"
    );

    match ctx
        .data()
        .crab
        .issues("joshua-mo-143", "test")
        .create(issue_title)
        .body(message)
        .send()
        .await
    {
        Ok(res) => {
            ctx.say(format!("This issue was successfully elevated to a GitHub issue! You can find the issue at: {}
                \n---\n
                The thread will now be locked to avoid needing to keep both communication channels synced with each other. 
                \nIf you're not the original poster and you're having the same issue, please open a new Help thread or comment on the GitHub issue.
                \n---\n
                Thank you!", &res.html_url))
                .await?;

            Thread::set_locked_status(ctx, true).await?;

            if let Err(e) = ctx
                .data()
                .db
                .clone()
                .discord_elevate_thread(res.html_url.into(), thread_url)
                .await
            {
                return Err(format!("Couldn't elevate thread: {e}").into());
            }
        }

        Err(e) => {
            error!("Error creating Github issue: {:?}", e);
        }
    }

    Ok(())
}

/// (un)Lock a thread
#[poise::command(slash_command, check = "check_role")]
pub async fn set_locked(
    ctx: Context<'_>,
    #[description = "Set true to lock, set false to unlock"] locked: bool,
    #[description = "Reason for locking thread"] reason: String,
) -> Result<(), Error> {
    let thread_url = Thread::url_from_poise_ctx(ctx);

    let message = if locked {
        format!("Locking thread. Reason: {reason}")
    } else {
        format!("Unlocking thread. Reason: {reason}")
    };

    ctx.say(message).await?;
    Thread::set_locked_status(ctx, locked).await?;

    if let Err(e) = ctx
        .data()
        .db
        .clone()
        .discord_change_locked_status(locked, reason, thread_url)
        .await
    {
        return Err(format!("Error while setting locked status on thread: {e}").into());
    }

    Ok(())
}

#[poise::command(slash_command)]
pub async fn resolve(ctx: Context<'_>) -> Result<(), Error> {
    ctx.defer().await?;
    
    let thread_url = Thread::url_from_poise_ctx(ctx);

    let member_count: i32 = ctx.channel_id().get_thread_members(&ctx.http()).await.unwrap().len().to_string().parse::<i32>().unwrap() -1;

    let messages_len = ctx
        .channel_id()
        .messages(ctx.http(), |message| message)
        .await
        .unwrap()
        .len().to_string().parse::<i32>().unwrap();
    let mut messages = ctx
        .channel_id()
        .messages(ctx.http(), |message| message)
        .await
        .unwrap();
    messages.reverse();

    Thread::set_locked_status(ctx, true).await?;

    let thread_author_name = &messages.first().unwrap().author.name;

    let _ = messages
        .iter()
        .filter(|x| x.author.name == *thread_author_name);

    let resolved_by = messages
        .into_iter()
        .fold(HashMap::<String, usize>::new(), |mut m, x| {
            *m.entry(x.author.name).or_default() += 1;
            m
        })
        .into_iter()
        .max_by_key(|(_, v)| *v)
        .map(|(k, _)| k)
        .unwrap();

    if let Err(e) = ctx
        .data()
        .db
        .clone()
        .discord_resolve_thread(resolved_by, thread_url, messages_len, member_count)
        .await
    {
        return Err(format!("Error when resolving thread: {e}").into());
    }

    helpthread_feedback_prompt(&ctx)
        .await
        .expect("Error while attempting to get feedback");


    Ok(())
}

#[poise::command(slash_command, ephemeral, check = "check_role")]
pub async fn set_severity(
    ctx: Context<'_>,
    #[description = "Severity level"] severity: SeverityCategory,
) -> Result<(), Error> {
    let thread_url = Thread::url_from_poise_ctx(ctx);

    if let Err(e) = ctx
        .data()
        .db
        .clone()
        .discord_set_catsev(severity.to_num(), thread_url)
        .await
    {
        return Err(format!("Error when setting category severity: {e}").into());
    }

    let message = format!(
        "This thread has now been set to Category {} severity.",
        severity.to_num()
    );

    ctx.say(message).await?;


    Ok(())
}

#[derive(Debug, poise::ChoiceParameter)]
pub enum SeverityCategory {
    #[name = "Category 1 (Shuttle is broken until this issue is fixed)"]
    One,
    #[name = "Category 2 (Major inconvenience to many or most Shuttle users)"]
    Two,
    #[name = "Category 3 (Minor inconvenience to many or most Shuttle users)"]
    Three,
    #[name = "Category 4 (Major inconvenience to one person or total service outage)"]
    Four,
    #[name = "Category 5 (Minor inconvenience to one person)"]
    Five,
}

impl SeverityCategory {
    fn to_num(&self) -> i32 {
        match self {
            SeverityCategory::One => 1,
            SeverityCategory::Two => 2,
            SeverityCategory::Three => 3,
            SeverityCategory::Four => 4,
            SeverityCategory::Five => 5,
        }
    }
}

#[derive(Clone, Debug)]
pub struct Issue {
    discord_thread_id: Option<String>, // unused
    discord_thread_url: Option<String>,
    origin: String,
    original_poster: Option<String>,
    initial_message: Option<String>,
    first_response_user: Option<String>,
    resolver_user: Option<String>,
    github_link: Option<String>,
    locked: bool,
    resolved: bool,
    first_response_time_date: Option<chrono::DateTime<Utc>>,
    resolved_time_date: Option<chrono::DateTime<Utc>>
}

impl Default for Issue {
    fn default() -> Self {
        Self {
            discord_thread_id: None,
            discord_thread_url: None,
            origin: "discord".to_string(),
            initial_message: None,
            original_poster: None,
            first_response_user: None,
            resolver_user: None,
            github_link: None,
            locked: false,
            resolved: false,
            first_response_time_date: None,
            resolved_time_date: None,
        }
    }
}

#[poise::command(slash_command, check = "check_role")]
pub async fn refresh(ctx: Context<'_>) -> Result<(), Error> {
    let _ = ctx.defer().await;
    let mut issues_list: Vec<Issue> = Vec::new();

    // get github issues
    let github_issues = ctx
        .data()
        .crab
        .issues("joshua-mo-143", "test")
        .list()
        .send()
        .await?;
    let mut github_auto_issues = github_issues.items.clone();
    let mut github_user_submitted_issues = github_issues.items.clone();

    // filter for autogenerated issues only
    github_auto_issues.retain(|issue| issue.title.starts_with("[AUTOGENERATED]"));
    github_user_submitted_issues.retain(|issue| !issue.title.starts_with("[AUTOGENERATED]"));
    // get all discord channels and only get the ones that are in the Help channel
    let mut discord_threads = ctx
        .http()
        .get_guild(ctx.data().server_id.parse::<u64>().unwrap())
        .await
        .unwrap()
        .get_active_threads(&ctx.http())
        .await.unwrap()
        .threads;

    
    discord_threads.retain(|channel| channel.parent_id == Some(1116377484296978452u64.into()));

    // add messages
    for thread in discord_threads.clone() {
        let mut messages = thread
            .messages(&ctx.http(), |message| message)
            .await
            .unwrap();

        messages.reverse();

        let first_response_user = if messages.len() > 1 {Some(messages[1].author.name.clone())} else {None};
        
        issues_list.push(Issue {
            discord_thread_id: Some(thread.id.to_string()),
            discord_thread_url: Some(format!(
                "https://www.discord.com/channels/1072109825674203136/{}",
                thread.id
            )),
            original_poster: Some(messages[0].author.name.clone()),
            first_response_user,
            ..Default::default()
        });
    }

    // parse github issue body for URL; add the github link to the struct
    for issue in github_auto_issues {
        let regex =
            regex::Regex::new(r"https://discord.com/channels/1072109825674203136/[0-9]{19}").unwrap();
        let body = issue.body.unwrap();
        let found = regex.find(&body).unwrap().as_str();

        for mut thread in issues_list.clone() {
            if thread.discord_thread_url == Some(found.to_string()) {
                thread.github_link = Some(issue.html_url.to_string());
            }
        }
    }

    for issue in github_user_submitted_issues {
        println!("{:?}", issue);
        let comments = match octocrab::instance().issues("joshua-mo-143", "test").list_comments(*issue.id).send().await {
            Ok(res) => Some(res),
            Err(_) => None
        };

        // unwrap ok here as we've already error matched it
        // typically there will be an error if there are no comments
        if comments.is_some() {
        let mut comments = comments.unwrap();
        let last_comment = if  issue.state == IssueState::Closed {comments.items.pop()} else {None};
        let first_response_user = if comments.items.len() > 1 {Some(comments.items[1].user.login.clone())} else {None};
        let first_response_time_date = if comments.items.len() > 1 {Some(comments.items[1].created_at)} else {None};
            
        issues_list.push(Issue {
            origin: "github".to_string(),
            original_poster: Some(issue.user.login),
            first_response_user,
            resolver_user: if issue.state == IssueState::Closed {Some(last_comment.clone().unwrap().user.login)} else {None},
            github_link: Some(issue.html_url.to_string()),
            locked: issue.state == IssueState::Closed,
            resolved: issue.state == IssueState::Closed,
            first_response_time_date,
            resolved_time_date: if issue.state == IssueState::Closed {last_comment.unwrap().updated_at} else {None},
            ..Default::default()
        })
        } else {
            
        issues_list.push(Issue {
            origin: "github".to_string(),
            original_poster: Some(issue.user.login),
            github_link: Some(issue.html_url.to_string()),
            locked: issue.state == IssueState::Closed,
            resolved: issue.state == IssueState::Closed,
            .. Default::default()
        })
        }        
    }

    for issue in issues_list {
        if let Err(e) = sqlx::query(
            "INSERT INTO issues (
            origin, 
            discordthreadid,
            discordthreadlink,
            originalposter, 
            initialmessage, 
            firstresponseuser, 
            resolveruser, 
            githublink, 
            locked, 
            resolved, 
            resolvedtimedate) VALUES ( 
            $1,
            $2,
            $3,
            $4,
            $5,
            $6,
            $7,
            $8,
            $9,
            $10,
            $11) ON CONFLICT DO NOTHING"
        )
        .bind(issue.origin)
        .bind(issue.discord_thread_id)
        .bind(issue.discord_thread_url) // original poster
        .bind(issue.original_poster) // original poster
        .bind(issue.initial_message) // initial message
        .bind(issue.first_response_user) // first response user
        .bind(issue.resolver_user) // resolver user
        .bind(issue.github_link) // github link
        .bind(issue.locked) // locked
        .bind(issue.resolved) // resolved
        .bind(issue.resolved_time_date) // resolvedtimedate
        .execute(&ctx.data().db.db)
        .await
        {
            ctx.say(format!("Error when refreshing: {e}")).await?;
        }
    }

    ctx.say("Migrations done!").await?;

    Ok(())
}

pub async fn helpthread_feedback_prompt(ctx: &Context<'_>) -> Result<(), SerenityError> {
    let message = ctx.channel_id().say(ctx.http(), "Looks like this issue's been resolved! 
        Feel free to give us feedback on whether this thread helped you by reacting with a thumbs up or down.\n This thread will now be locked.")
            .await.unwrap();

    message.react(ctx.http(), '👍').await.unwrap();
    message.react(ctx.http(), '👎').await.unwrap();

    Ok(())
}