use crate::utils::Thread;
use crate::Context;
use crate::Error;
use poise::serenity_prelude::CacheHttp;
use tracing::error;
use std::collections::HashMap;

/// Link to Shuttle documentation
#[poise::command(slash_command)]
pub async fn docs(
    ctx: Context<'_>,
    #[description = "The docs you want to link to"] docs: DocsLinks,
) -> Result<(), Error> {
    ctx.say(docs.to_link()).await?;
    Ok(())
}

#[derive(Debug, poise::ChoiceParameter)]
pub enum DocsLinks {
    #[name = "documentation on setting up secrets/env"]
    Secrets,
    #[name = "documentation on provisioned databases via shared databases"]
    Databases,
    #[name = "documentation on setting up a simple key-value store"]
    Persist,
    #[name = "documentation on setting up static files"]
    Assets,
    #[name = "Documentation on setting up a custom service"]
    Custom,
}

impl DocsLinks {
    pub fn to_link(&self) -> String {
        match self {
            DocsLinks::Secrets => String::from("https://docs.shuttle.rs/resources/shuttle-secrets"),
            DocsLinks::Databases => {
                String::from("https://docs.shuttle.rs/resources/shuttle-shared-db")
            }
            DocsLinks::Persist => String::from("https://docs.shuttle.rs/resources/shuttle-persist"),
            DocsLinks::Assets => {
                String::from("https://docs.shuttle.rs/resources/shuttle-static-folder")
            }
            DocsLinks::Custom => String::from("https://docs.shuttle.rs/tutorials/custom-service"),
        }
    }
}

async fn check_role(ctx: Context<'_>) -> Result<bool, Error> {
    let Ok(res) = ctx.author().has_role(
        ctx.http(),
        ctx.data().server_id.parse::<u64>().unwrap(),
        ctx.data().staff_role_id.parse::<u64>().unwrap()
    ).await else {
         {error!("Something went wrong trying to check permissions.");
        return Ok(false)}
    };

    match res {
        true => Ok(true),
        false => Ok(false),
    }
}

/// Elevate a Discord help thread to a GitHub issue. This locks the thread.
#[poise::command(slash_command, check = "check_role")]
pub async fn elevate(ctx: Context<'_>) -> Result<(), Error> {
    let topic = Thread::get(ctx).await.name;

    let thread_url = Thread::url_from_poise_ctx(ctx);

    let messages = ctx
        .channel_id()
        .messages(ctx.http(), |message| message)
        .await
        .unwrap();

    let first_message = messages.last().unwrap();

    let message_content = first_message.content.clone();

    let issue_title = format!("[AUTOGENERATED] {topic}");

    let message = format!(
        "<sub>Generated from a [discord help thread.]({thread_url})</sub>\n---\n{message_content}"
    );

    match ctx
        .data()
        .crab
        .issues("joshua-mo-143", "test")
        .create(issue_title)
        .body(message)
        .send()
        .await
    {
        Ok(res) => {
            ctx.say(format!("This issue was successfully elevated to a GitHub issue! You can find the issue at: {}
                \n---\n
                The thread will now be locked to avoid needing to keep both communication channels synced with each other. 
                \nIf you're not the original poster and you're having the same issue, please open a new Help thread or comment on the GitHub issue.
                \n---\n
                Thank you!", &res.html_url))
                .await?;

            Thread::set_locked_status(ctx, true).await?;

            if let Err(e) = ctx
                .data()
                .db
                .clone()
                .discord_elevate_thread(res.html_url.into(), thread_url)
                .await
            {
                return Err(format!("Couldn't elevate thread: {e}").into());
            }
        }

        Err(e) => {
            error!("Error creating Github issue: {:?}", e);
        }
    }

    Ok(())
}

/// (un)Lock a thread
#[poise::command(slash_command, check = "check_role")]
pub async fn set_locked(
    ctx: Context<'_>,
    #[description = "Set true to lock, set false to unlock"] locked: bool,
    #[description = "Reason for locking thread"] reason: String,
) -> Result<(), Error> {
    let thread_url = Thread::url_from_poise_ctx(ctx);

    let message = if locked {
        format!("Locking thread. Reason: {reason}")
    } else {
        format!("Unlocking thread. Reason: {reason}")
    };

    ctx.say(message).await?;
    Thread::set_locked_status(ctx, locked).await?;

    if let Err(e) = ctx
        .data()
        .db
        .clone()
        .discord_change_locked_status(locked, reason, thread_url)
        .await
    {
        return Err(format!("Error while setting locked status on thread: {e}").into());
    }

    Ok(())
}

#[poise::command(slash_command)]
pub async fn resolve(
    ctx: Context<'_>,
) -> Result<(), Error> {
    let thread_url = Thread::url_from_poise_ctx(ctx);

    Thread::set_locked_status(ctx, true).await?;

    let messages_len = ctx.channel_id().messages(ctx.http(), |message| message).await.unwrap().len();
    let mut messages = ctx.channel_id().messages(ctx.http(), |message| message).await.unwrap();
    messages.reverse();

    let thread_author_name = &messages.first().unwrap().author.name;

    let _ = messages.iter().filter(|x| x.author.name == *thread_author_name);

    let resolved_by = messages.into_iter()
        .fold(HashMap::<String, usize>::new(), |mut m, x| {
            *m.entry(x.author.name).or_default() += 1;
            m
        })
        .into_iter()
        .max_by_key(|(_, v)| *v)
        .map(|(k, _)| k).unwrap();
    
    let message = format!("It looks like this thread has been resolved, so {resolved_by} has invoked this command. 
        The thread will now be locked.\n 
        ");
    
    ctx.say(message).await?;

    if let Err(e) = ctx
        .data()
        .db
        .clone()
        .discord_resolve_thread(resolved_by, thread_url)
        .await
    {
        return Err(format!("Error when resolving thread: {e}").into());
    }


    Ok(())
}

#[poise::command(slash_command, ephemeral, check = "check_role")]
pub async fn set_severity(
    ctx: Context<'_>,
    #[description = "Severity level"] severity: SeverityCategory,
) -> Result<(), Error> {
    let thread_url = Thread::url_from_poise_ctx(ctx);

    if let Err(e) = ctx
        .data()
        .db
        .clone()
        .discord_set_catsev(severity.to_num(), thread_url)
        .await
    {
        return Err(format!("Error when setting category severity: {e}").into());
    }

    let message = format!(
        "This thread has now been set to Category {} severity.",
        severity.to_num()
    );

    ctx.say(message).await?;

    Ok(())
}

#[derive(Debug, poise::ChoiceParameter)]
pub enum SeverityCategory {
    #[name = "Category 1 (Shuttle is broken until this issue is fixed)"]
    One,
    #[name = "Category 2 (Major inconvenience to many or most Shuttle users)"]
    Two,
    #[name = "Category 3 (Minor inconvenience to many or most Shuttle users)"]
    Three,
    #[name = "Category 4 (Major inconvenience to one person or total service outage)"]
    Four,
    #[name = "Category 5 (Minor inconvenience to one person)"]
    Five,
}

impl SeverityCategory {
    fn to_num(&self) -> i32 {
        match self {
            SeverityCategory::One => 1,
            SeverityCategory::Two => 2,
            SeverityCategory::Three => 3,
            SeverityCategory::Four => 4,
            SeverityCategory::Five => 5,
        }
    }
}

#[poise::command(slash_command)]
pub async fn get_feedback(ctx: Context<'_>) -> Result<(), Error> {

    ctx.send(|m| 
        m.components(|components| 
            components.create_action_row(|row| 
                row.create_button(|button| button )
            )
        )
    ).await?;
    
    Ok(())
} 