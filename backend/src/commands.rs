use crate::utils::Thread;
use crate::Context;
use crate::Error;
use poise::serenity_prelude::{
    model::application::interaction::InteractionResponseType, CacheHttp, Error as SerenityError,
    Message,
};
use std::collections::HashMap;
use tracing::error;
use octocrab::models::IssueState;
use sqlx::types::chrono::Utc;

/// Link to Shuttle documentation
#[poise::command(slash_command)]
pub async fn docs(
    ctx: Context<'_>,
    #[description = "The docs you want to link to"] docs: DocsLinks,
) -> Result<(), Error> {
    ctx.say(docs.to_link()).await?;
    Ok(())
}

#[derive(Debug, poise::ChoiceParameter)]
pub enum DocsLinks {
    #[name = "documentation on setting up secrets/env"]
    Secrets,
    #[name = "documentation on provisioned databases via shared databases"]
    Databases,
    #[name = "documentation on setting up a simple key-value store"]
    Persist,
    #[name = "documentation on setting up static files"]
    Assets,
    #[name = "Documentation on setting up a custom service"]
    Custom,
}

impl DocsLinks {
    pub fn to_link(&self) -> String {
        match self {
            DocsLinks::Secrets => String::from("https://docs.shuttle.rs/resources/shuttle-secrets"),
            DocsLinks::Databases => {
                String::from("https://docs.shuttle.rs/resources/shuttle-shared-db")
            }
            DocsLinks::Persist => String::from("https://docs.shuttle.rs/resources/shuttle-persist"),
            DocsLinks::Assets => {
                String::from("https://docs.shuttle.rs/resources/shuttle-static-folder")
            }
            DocsLinks::Custom => String::from("https://docs.shuttle.rs/tutorials/custom-service"),
        }
    }
}

async fn check_role(ctx: Context<'_>) -> Result<bool, Error> {
    let Ok(res) = ctx.author().has_role(
        ctx.http(),
        ctx.data().server_id.parse::<u64>().unwrap(),
        ctx.data().staff_role_id.parse::<u64>().unwrap()
    ).await else {
         {error!("Something went wrong trying to check permissions.");
        return Ok(false)}
    };

    match res {
        true => Ok(true),
        false => Ok(false),
    }
}

/// Elevate a Discord help thread to a GitHub issue. This locks the thread.
#[poise::command(slash_command, check = "check_role")]
pub async fn elevate(ctx: Context<'_>) -> Result<(), Error> {
    let topic = Thread::get(ctx).await.name;

    let thread_url = Thread::url_from_poise_ctx(ctx);

    let messages = ctx
        .channel_id()
        .messages(ctx.http(), |message| message)
        .await
        .unwrap();

    let first_message = messages.last().unwrap();

    let message_content = first_message.content.clone();

    let issue_title = format!("[AUTOGENERATED] {topic}");

    let message = format!(
        "<sub>Generated from a [discord help thread.]({thread_url})</sub>\n---\n{message_content}"
    );

    match ctx
        .data()
        .crab
        .issues("joshua-mo-143", "test")
        .create(issue_title)
        .body(message)
        .send()
        .await
    {
        Ok(res) => {
            ctx.say(format!("This issue was successfully elevated to a GitHub issue! You can find the issue at: {}
                \n---\n
                The thread will now be locked to avoid needing to keep both communication channels synced with each other. 
                \nIf you're not the original poster and you're having the same issue, please open a new Help thread or comment on the GitHub issue.
                \n---\n
                Thank you!", &res.html_url))
                .await?;

            Thread::set_locked_status(ctx, true).await?;

            if let Err(e) = ctx
                .data()
                .db
                .clone()
                .discord_elevate_thread(res.html_url.into(), thread_url)
                .await
            {
                return Err(format!("Couldn't elevate thread: {e}").into());
            }
        }

        Err(e) => {
            error!("Error creating Github issue: {:?}", e);
        }
    }

    Ok(())
}

/// (un)Lock a thread
#[poise::command(slash_command, check = "check_role")]
pub async fn set_locked(
    ctx: Context<'_>,
    #[description = "Set true to lock, set false to unlock"] locked: bool,
    #[description = "Reason for locking thread"] reason: String,
) -> Result<(), Error> {
    let thread_url = Thread::url_from_poise_ctx(ctx);

    let message = if locked {
        format!("Locking thread. Reason: {reason}")
    } else {
        format!("Unlocking thread. Reason: {reason}")
    };

    ctx.say(message).await?;
    Thread::set_locked_status(ctx, locked).await?;

    if let Err(e) = ctx
        .data()
        .db
        .clone()
        .discord_change_locked_status(locked, reason, thread_url)
        .await
    {
        return Err(format!("Error while setting locked status on thread: {e}").into());
    }

    Ok(())
}

#[poise::command(slash_command)]
pub async fn resolve(ctx: Context<'_>) -> Result<(), Error> {
    let thread_url = Thread::url_from_poise_ctx(ctx);

    Thread::set_locked_status(ctx, true).await?;

    let messages_len = ctx
        .channel_id()
        .messages(ctx.http(), |message| message)
        .await
        .unwrap()
        .len();
    let mut messages = ctx
        .channel_id()
        .messages(ctx.http(), |message| message)
        .await
        .unwrap();
    messages.reverse();

    let thread_author_name = &messages.first().unwrap().author.name;

    let _ = messages
        .iter()
        .filter(|x| x.author.name == *thread_author_name);

    let resolved_by = messages
        .into_iter()
        .fold(HashMap::<String, usize>::new(), |mut m, x| {
            *m.entry(x.author.name).or_default() += 1;
            m
        })
        .into_iter()
        .max_by_key(|(_, v)| *v)
        .map(|(k, _)| k)
        .unwrap();

    let message = format!(
        "It looks like this thread has been resolved, so {resolved_by} has invoked this command. 
        The thread will now be locked.\n 
        "
    );

    ctx.say(message).await?;

    if let Err(e) = ctx
        .data()
        .db
        .clone()
        .discord_resolve_thread(resolved_by, thread_url)
        .await
    {
        return Err(format!("Error when resolving thread: {e}").into());
    }

    get_feedback(ctx)
        .await
        .expect("Error while attempting to get feedback");

    Ok(())
}

#[poise::command(slash_command, ephemeral, check = "check_role")]
pub async fn set_severity(
    ctx: Context<'_>,
    #[description = "Severity level"] severity: SeverityCategory,
) -> Result<(), Error> {
    let thread_url = Thread::url_from_poise_ctx(ctx);

    if let Err(e) = ctx
        .data()
        .db
        .clone()
        .discord_set_catsev(severity.to_num(), thread_url)
        .await
    {
        return Err(format!("Error when setting category severity: {e}").into());
    }

    let message = format!(
        "This thread has now been set to Category {} severity.",
        severity.to_num()
    );

    ctx.say(message).await?;

    Ok(())
}

#[derive(Debug, poise::ChoiceParameter)]
pub enum SeverityCategory {
    #[name = "Category 1 (Shuttle is broken until this issue is fixed)"]
    One,
    #[name = "Category 2 (Major inconvenience to many or most Shuttle users)"]
    Two,
    #[name = "Category 3 (Minor inconvenience to many or most Shuttle users)"]
    Three,
    #[name = "Category 4 (Major inconvenience to one person or total service outage)"]
    Four,
    #[name = "Category 5 (Minor inconvenience to one person)"]
    Five,
}

impl SeverityCategory {
    fn to_num(&self) -> i32 {
        match self {
            SeverityCategory::One => 1,
            SeverityCategory::Two => 2,
            SeverityCategory::Three => 3,
            SeverityCategory::Four => 4,
            SeverityCategory::Five => 5,
        }
    }
}

#[derive(Clone)]
pub struct Issue {
    discord_thread_id: Option<String>,
    discord_thread_url: Option<String>,
    origin: String,
    original_poster: String,
    initial_message: String,
    first_response_user: Option<String>,
    resolver_user: Option<String>,
    github_link: Option<String>,
    locked: bool,
    resolved: bool,
    first_response_time_date: Option<chrono::DateTime<Utc>>,
    resolved_time_date: Option<chrono::DateTime<Utc>>
}

impl Default for Issue {
    fn default() -> Self {
        Self {
            discord_thread_id: None,
            discord_thread_url: None,
            origin: "discord".to_string(),
            initial_message: "".to_string(),
            original_poster: "".to_string(),
            first_response_user: None,
            resolver_user: None,
            github_link: None,
            locked: false,
            resolved: false,
            first_response_time_date: None,
            resolved_time_date: None,
        }
    }
}

#[poise::command(slash_command, check = "check_role")]
pub async fn refresh(ctx: Context<'_>) -> Result<(), Error> {
    let mut issues_list = Vec::new();

    // get github issues
    let github_issues = ctx
        .data()
        .crab
        .issues("joshua-mo-143", "test")
        .list()
        .send()
        .await?;
    let mut github_auto_issues = github_issues.items.clone();
    let mut github_user_submitted_issues = github_issues.items.clone();

    // filter for autogenerated issues only
    github_auto_issues.retain(|issue| issue.title.starts_with("[AUTOGENERATED]"));
    github_user_submitted_issues.retain(|issue| !issue.title.starts_with("[AUTOGENERATED]"));

    // get all discord channels and only get the ones that are in the Help channel
    let mut discord_threads = ctx
        .http()
        .get_channels(ctx.data().server_id.parse::<u64>().unwrap())
        .await
        .unwrap();

    discord_threads.retain(|channel| channel.parent_id == Some(1116377484296978452u64.into()));

    // add messages
    for thread in discord_threads.clone() {
        let mut messages = thread
            .messages(&ctx.http(), |message| message)
            .await
            .unwrap();
        messages.reverse();
        issues_list.push(Issue {
            discord_thread_id: Some(thread.id.to_string()),
            discord_thread_url: Some(format!(
                "https://www.discord.com/1072109825674203136/{}",
                thread.id
            )),
            original_poster: messages[0].author.name.clone(),
            first_response_user: Some(messages[1].author.name.clone()),
            ..Default::default()
        });
    }

    // parse github issue body for URL; add the github link to the struct
    for issue in github_auto_issues {
        let regex =
            regex::Regex::new(r"https://discord.com/channels/1072109825674203136/[0-9]{19}").unwrap();
        let body = issue.body.unwrap();
        let found = regex.find(&body).unwrap().as_str();

        for mut thread in issues_list.clone() {
            if thread.discord_thread_url == Some(found.to_string()) {
                thread.github_link = Some(issue.html_url.to_string());
            }
        }
    }

    for issue in github_user_submitted_issues {
        let mut comments = octocrab::instance().issues("joshua-mo-143", "test").list_comments(*issue.id).send().await?;
        
        issues_list.push(Issue {
            origin: "github".to_string(),
            original_poster: issue.user.login,
            first_response_user: {Some(comments.items[1].user.login.clone())},
            resolver_user: if issue.state == IssueState::Closed {Some(comments.items.pop().unwrap().user.login)} else {None},
            github_link: Some(issue.html_url.to_string()),
            locked: issue.state == IssueState::Closed,
            resolved: issue.state == IssueState::Closed,
            first_response_time_date: None,
            resolved_time_date: None,
            ..Default::default()
        })
    }

    for issue in issues_list {
        if let Err(e) = sqlx::query!(
            "INSERT INTO issues (origin, 
            discordthreadlink,
            originalposter, 
            initialmessage, 
            firstresponseuser, 
            resolveruser, 
            githublink, 
            locked, 
            resolved, 
            resolvedtimedate) VALUES ( 
            $1,
            $2,
            $3,
            $4,
            $5,
            $6,
            $7,
            $8,
            $9,
            $10)",
            
        issue.origin,
        issue.discord_thread_url, // original poster
        issue.original_poster, // original poster
        issue.initial_message, // initial message
        issue.first_response_user, // first response user
        issue.resolver_user, // resolver user
        issue.github_link, // github link
        issue.locked, // locked
        issue.resolved, // resolved
        issue.resolved_time_date, // resolvedtimedate
        )
        .execute(&ctx.data().db.db)
        .await
        {
            error!("Error when refreshing: {e}");
        }
    }

    ctx.say("Migrations done!").await?;

    Ok(())
}

pub async fn get_feedback(ctx: Context<'_>) -> Result<(), Error> {
    let message = helpthread_feedback_prompt(&ctx).await?;

    let interaction = match message.await_component_interaction(ctx).await {
        Some(x) => x,
        None => {
            return Ok(());
        }
    };

    println!("{:?}", &interaction.data.values[0]);

    interaction
        .create_interaction_response(&ctx, |r| {
            r.kind(InteractionResponseType::ChannelMessageWithSource)
                .interaction_response_data(|d| d.content("Thanks for your response!"))
        })
        .await
        .unwrap();

    Ok(())
}

pub async fn helpthread_feedback_prompt(ctx: &Context<'_>) -> Result<Message, SerenityError> {
    ctx.send(|m| {
        m.components(|components| {
            components.create_action_row(|row| {
                row.create_select_menu(|menu| {
                    menu.custom_id("user_feedback");
                    menu.placeholder("Did you feel like this thread solved your issue?");
                    menu.options(|f| {
                        f.create_option(|o| o.label("Yes").value("Yes"));
                        f.create_option(|o| o.label("No").value("No"));

                        f
                    });

                    menu
                })
            })
        })
    })
    .await?
    .into_message()
    .await
}
