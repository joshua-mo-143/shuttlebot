use crate::utils::Thread;
use crate::Context;
use crate::Error;
use poise::serenity_prelude::CacheHttp;
use tracing::error;

/// Link to Shuttle documentation
#[poise::command(slash_command)]
pub async fn docs(
    ctx: Context<'_>,
    #[description = "The docs you want to link to"] docs: DocsLinks,
) -> Result<(), Error> {
    ctx.say(docs.to_link()).await?;
    Ok(())
}

#[derive(Debug, poise::ChoiceParameter)]
pub enum DocsLinks {
    #[name = "documentation on setting up secrets/env"]
    Secrets,
    #[name = "documentation on provisioned databases via shared databases"]
    Databases,
    #[name = "documentation on setting up a simple key-value store"]
    Persist,
    #[name = "documentation on setting up static files"]
    Assets,
    #[name = "Documentation on setting up a custom service"]
    Custom,
}

impl DocsLinks {
    pub fn to_link(&self) -> String {
        match self {
            DocsLinks::Secrets => String::from("https://docs.shuttle.rs/resources/shuttle-secrets"),
            DocsLinks::Databases => {
                String::from("https://docs.shuttle.rs/resources/shuttle-shared-db")
            }
            DocsLinks::Persist => String::from("https://docs.shuttle.rs/resources/shuttle-persist"),
            DocsLinks::Assets => {
                String::from("https://docs.shuttle.rs/resources/shuttle-static-folder")
            }
            DocsLinks::Custom => String::from("https://docs.shuttle.rs/tutorials/custom-service"),
        }
    }
}

/// Elevate a Discord help thread to a GitHub issue. This locks the thread.
#[poise::command(slash_command)]
pub async fn elevate(
    ctx: Context<'_>,
    #[description = "Add extra contextual notes"] notes: Option<String>,
) -> Result<(), Error> {
    let notes = if notes.is_some() {
        notes.unwrap()
    } else {
        "None".to_string()
    };

    let topic = Thread::get(ctx).await.name;

    let thread_url = {
        format!(
            "https://discord.com/channels/{}/{}",
            ctx.guild_id().unwrap(),
            ctx.channel_id()
        )
    };

    let messages = ctx
        .channel_id()
        .messages(ctx.http(), |message| message)
        .await
        .unwrap();

    let first_message = messages.last().unwrap();
    let original_poster = first_message.author.name.clone();
    let message_content = first_message.content.clone();

    let issue_title = format!("[AUTOGENERATED] {topic}");

    let message = format!("{message_content}\nGenerated from a [discord help thread.]({thread_url})");

    match ctx
        .data()
        .crab
        .issues("joshua-mo-143", "test")
        .create(issue_title)
        .body(message)
        .send()
        .await
    {
        Ok(res) => {
            ctx.say(format!("This issue was successfully elevated to a GitHub issue! You can find the issue at: {}
                \n---\n
                The thread will now be locked to avoid needing to keep both communication channels synced with each other. 
                \nIf you're not the original poster and you're having the same issue, please open a new Help thread or comment on the GitHub issue.
                \n---\n
                Thank you!", res.html_url))
                .await?;

            Thread::set_locked_status(ctx, true).await?;

            if let Err(e) = sqlx::query(
                "UPDATE issues SET 
                GithubLink = $1, 
                Locked = TRUE,
                LockStatusChangeReason = 'Thread was elevated to GitHub issue'
                WHERE DiscordThreadId = $3",
            )
            .bind(res.html_url.to_string())
            .bind(ctx.author().id.to_string())
            .bind(ctx.channel_id().to_string())
            .execute(&ctx.data().pool)
            .await
            {
                error!(
                    "Failed to update SQL record after elevating GitHub issue: {:?}",
                    e
                );
            }
        }

        Err(e) => {
            error!("Error creating Github issue: {:?}", e);
        }
    }

    Ok(())
}

/// (un)Lock a thread
#[poise::command(slash_command)]
pub async fn set_locked(
    ctx: Context<'_>,
    #[description = "Set true to lock, set false to unlock"] locked: bool,
    #[description = "Reason for locking thread"] reason: String,
) -> Result<(), Error> {
    let message = if locked {
        format!("Locking thread. Reason: {reason}")
    } else {
        format!("Unlocking thread. Reason: {reason}")
    };

    ctx.say(message).await?;
    Thread::set_locked_status(ctx, locked).await?;

    if let Err(e) = sqlx::query(
        "UPDATE issues SET
        Locked = $1, 
        LockStatusChangeReason = $2, 
        ResolvedTimedate = CURRENT_TIMESTAMP 
        WHERE DiscordThreadId = $3",
    )
    .bind(locked)
    .bind(reason)
    .bind(ctx.channel_id().to_string())
    .execute(&ctx.data().pool)
    .await
    {
        error!(
            "Error when updating SQL record after thread lock status: {:?}",
            e
        );
    }

    Ok(())
}

#[poise::command(slash_command)]
pub async fn resolve(ctx: Context<'_>) -> Result<(), Error> {
    let name = ctx.author().name.clone();

    let message = format!("It looks like this thread has been resolved, so {name} has invoked this command. 
        The thread will now be locked.\n 
        If you're still having an issue with this, please feel free to open another thread detailing your issue.");

    ctx.say(message).await?;
    Thread::set_locked_status(ctx, true).await?;

    if let Err(e) = sqlx::query(
        "UPDATE issues SET
        Locked = true, 
        LockStatusChangeReason = 'Thread was resolved', 
        ResolvedTimedate = CURRENT_TIMESTAMP 
        WHERE DiscordThreadId = $1",
    )
    .bind(ctx.channel_id().to_string())
    .execute(&ctx.data().pool)
    .await
    {
        error!(
            "Error when updating SQL record after resolving thread: {:?}",
            e
        );
    }
    Ok(())
}

#[poise::command(slash_command, ephemeral)]
pub async fn set_severity(
    ctx: Context<'_>,
    #[description = "Severity level"] severity: SeverityCategory,
) -> Result<(), Error> {
    let message = format!(
        "This thread has now been set to Category {} severity.",
        severity.to_num()
    );

    ctx.say(message).await?;

    Ok(())
}

#[derive(Debug, poise::ChoiceParameter)]
pub enum SeverityCategory {
    #[name = "Category 1 (Shuttle is broken until this issue is fixed)"]
    One,
    #[name = "Category 2 (Major inconvenience to many or most Shuttle users)"]
    Two,
    #[name = "Category 3 (Minor inconvenience to many or most Shuttle users)"]
    Three,
    #[name = "Category 4 (Major inconvenience to one person or total service outage)"]
    Four,
    #[name = "Category 5 (Minor inconvenience to one person)"]
    Five,
}

impl SeverityCategory {
    fn to_num(&self) -> i32 {
        match self {
            SeverityCategory::One => 1,
            SeverityCategory::Two => 2,
            SeverityCategory::Three => 3,
            SeverityCategory::Four => 4,
            SeverityCategory::Five => 5,
        }
    }
}
